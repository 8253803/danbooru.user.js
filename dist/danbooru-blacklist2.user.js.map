{"version":3,"file":"danbooru-blacklist2.user.js","mappings":"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","sources":["webpack://danbooru-blacklist2/./src/AST.ts","webpack://danbooru-blacklist2/./src/Blacklist.ts","webpack://danbooru-blacklist2/./src/Post.ts","webpack://danbooru-blacklist2/./src/QueryParser.ts","webpack://danbooru-blacklist2/./src/StringParser.ts","webpack://danbooru-blacklist2/./src/StringScanner.ts","webpack://danbooru-blacklist2/./src/Tag.ts","webpack://danbooru-blacklist2/webpack/bootstrap","webpack://danbooru-blacklist2/./src/index.ts"],"sourcesContent":["import { Post } from \"./Post\";\n\nexport abstract class AST {\n  abstract match(post: Post): boolean;\n}\n\nexport class ASTAll extends AST {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  override match(_post: Post): boolean {\n    return true;\n  }\n}\n\nexport class ASTNone extends AST {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  override match(_post: Post): boolean {\n    return false;\n  }\n}\n\nexport class ASTAnd extends AST {\n  readonly left: AST;\n  readonly right: AST;\n\n  constructor(left: AST, right: AST) {\n    super();\n    this.left = left;\n    this.right = right;\n  }\n\n  override match(post: Post): boolean {\n    return this.left.match(post) && this.right.match(post);\n  }\n}\n\nexport class ASTOr extends AST {\n  readonly left: AST;\n  readonly right: AST;\n\n  constructor(left: AST, right: AST) {\n    super();\n    this.left = left;\n    this.right = right;\n  }\n\n  override match(post: Post): boolean {\n    return this.left.match(post) || this.right.match(post);\n  }\n}\n\nexport class ASTNot extends AST {\n  readonly node: AST;\n\n  constructor(node: AST) {\n    super();\n    this.node = node;\n  }\n\n  override match(post: Post): boolean {\n    return !this.node.match(post);\n  }\n}\n\nexport class ASTTag extends AST {\n  readonly tag: string;\n\n  constructor(tag: string) {\n    super();\n    this.tag = tag;\n  }\n\n  override match(post: Post): boolean {\n    return post.tags.includes(this.tag);\n  }\n}\n\nexport class ASTWildcard extends AST {\n  readonly wildcard: string;\n  private regex: RegExp;\n\n  constructor(wildcard: string) {\n    super();\n    this.wildcard = wildcard;\n    this.regex = RegExp(`^${wildcard.replaceAll(\"*\", \".*\")}$`, \"i\");\n  }\n\n  override match(post: Post): boolean {\n    return post.tags.some(\n      (tag: string): boolean => this.regex.exec(tag) !== null,\n    );\n  }\n}\n\nexport class ASTMetatag extends AST {\n  readonly name: string;\n  readonly value: string;\n\n  constructor(name: string, value: string) {\n    super();\n    this.name = name;\n    this.value = value;\n  }\n\n  override match(post: Post): boolean {\n    if (this.name === \"rating\") {\n      return post.rating === this.value.slice(0, 1);\n    }\n\n    if (this.name === \"score\") {\n      if (this.value.startsWith(\">\")) {\n        const value = parseInt(this.value.slice(1));\n        return post.score > value;\n      }\n\n      if (this.value.startsWith(\"<\")) {\n        const value = parseInt(this.value.slice(1));\n        return post.score < value;\n      }\n\n      const value = parseInt(this.value);\n      return post.score === value;\n    }\n\n    if (this.name === \"uploaderid\") {\n      const value = parseInt(this.value);\n      return post.uploaderId === value;\n    }\n\n    if (this.name === \"is\") {\n      if (this.value === \"pending\") {\n        return post.isPending;\n      }\n\n      if (this.value === \"flagged\") {\n        return post.isFlagged;\n      }\n\n      if (this.value === \"deleted\") {\n        return post.isDeleted;\n      }\n\n      if (this.value === \"banned\") {\n        return post.isBanned;\n      }\n\n      return false;\n    }\n\n    if (this.name === \"has\") {\n      if (this.value === \"parent\") {\n        return post.hasParent;\n      }\n\n      if (this.value === \"children\") {\n        return post.hasChildren;\n      }\n\n      return false;\n    }\n\n    return false;\n  }\n}\n","export enum Metatag {\n  rating = \"rating\",\n  score = \"score\",\n  uploaderid = \"uploaderid\",\n  is = \"is\",\n  has = \"has\",\n}\n","export class Post {\n  readonly tags: string[];\n  readonly score: number;\n  readonly rating: string;\n  readonly uploaderId: number;\n  readonly isPending: boolean;\n  readonly isFlagged: boolean;\n  readonly isDeleted: boolean;\n  readonly isBanned: boolean;\n  readonly hasParent: boolean;\n  readonly hasChildren: boolean;\n\n  private constructor(\n    tags: string[],\n    score: number,\n    rating: string,\n    uploaderId: number,\n    isPending: boolean,\n    isFlagged: boolean,\n    isDeleted: boolean,\n    isBanned: boolean,\n    hasParent: boolean,\n    hasChildren: boolean,\n  ) {\n    this.tags = tags;\n    this.score = score;\n    this.rating = rating;\n    this.uploaderId = uploaderId;\n    this.isPending = isPending;\n    this.isFlagged = isFlagged;\n    this.isDeleted = isDeleted;\n    this.isBanned = isBanned;\n    this.hasParent = hasParent;\n    this.hasChildren = hasChildren;\n  }\n\n  static fromElement(post: HTMLElement): Post {\n    const tags = post.dataset[\"tags\"]!.split(\" \");\n    const score = parseInt(post.dataset[\"score\"]!)!;\n    const rating = post.dataset[\"rating\"]!;\n    const uploaderId = parseInt(post.dataset[\"uploaderId\"]!)!;\n\n    const flags = post.dataset[\"flags\"]!.split(\" \");\n    const isPending = flags.includes(\"pending\");\n    const isFlagged = flags.includes(\"flagged\");\n    const isDeleted = flags.includes(\"deleted\");\n    const isBanned = flags.includes(\"banned\");\n\n    const hasParent = post.classList.contains(\"post-status-has-parent\");\n    const hasChildren = post.classList.contains(\"post-status-has-children\");\n\n    return new Post(\n      tags,\n      score,\n      rating,\n      uploaderId,\n      isPending,\n      isFlagged,\n      isDeleted,\n      isBanned,\n      hasParent,\n      hasChildren,\n    );\n  }\n}\n","import {\n  ASTAll,\n  AST,\n  ASTTag,\n  ASTWildcard,\n  ASTMetatag,\n  ASTNot,\n  ASTAnd,\n  ASTOr,\n  ASTNone,\n} from \"./AST\";\nimport { StringParser } from \"./StringParser\";\nimport { Tag } from \"./Tag\";\n\nexport class QueryParser {\n  parser: StringParser<number>;\n  metatagRegex: RegExp;\n\n  private constructor(input: string, metatags: string[]) {\n    this.parser = new StringParser<number>(input, 0);\n    this.metatagRegex = RegExp(`(${metatags.join(\"|\")}):`, \"i\");\n  }\n\n  static parse(input: string, metatags: string[] = []): AST {\n    return new QueryParser(input, metatags).parse();\n  }\n\n  private parse(): AST {\n    let ast: AST | null = this.root();\n\n    if (!this.parser.eos()) {\n      ast = null;\n    }\n\n    if (this.parser.state !== 0) {\n      ast = null;\n    }\n\n    if (ast === null) {\n      return new ASTNone();\n    }\n\n    return ast;\n  }\n\n  private root(): AST | null {\n    // eslint-disable-next-line prefer-const\n    let [a, ...rest] = this.parser.zeroOrMore(this.orClause.bind(this));\n    this.space();\n\n    if (a === undefined) {\n      return new ASTAll();\n    }\n\n    for (const b of rest) {\n      a = new ASTAnd(a, b);\n    }\n\n    return a;\n  }\n\n  private orClause(): AST | null {\n    const a = this.andClause();\n    if (a === null) {\n      return null;\n    }\n\n    this.space();\n\n    if (this.parser.accept(/or +/i) !== null) {\n      const b = this.orClause();\n      if (b === null) {\n        return null;\n      }\n      return new ASTOr(a, b);\n    }\n\n    return a;\n  }\n\n  private andClause(): AST | null {\n    const a = this.factorList();\n    if (a === null) {\n      return null;\n    }\n\n    this.space();\n\n    if (this.parser.accept(/and +/i) !== null) {\n      const b = this.andClause();\n      if (b === null) {\n        return null;\n      }\n      return new ASTAnd(a, b);\n    }\n\n    return a;\n  }\n\n  private factorList(): AST | null {\n    // eslint-disable-next-line prefer-const\n    let [a, ...rest] = this.parser.zeroOrMore(this.factor.bind(this));\n\n    if (a === undefined) {\n      return null;\n    }\n\n    for (const b of rest) {\n      a = new ASTAnd(a, b);\n    }\n\n    return a;\n  }\n\n  private factor(): AST | null {\n    this.space();\n\n    if (this.parser.accept(/-/) !== null) {\n      const expr = this.expr();\n      if (expr === null) {\n        return null;\n      }\n      return new ASTNot(expr);\n    }\n\n    if (this.parser.accept(/~/) !== null) {\n      return null;\n    }\n\n    return this.expr();\n  }\n\n  private expr(): AST | null {\n    this.space();\n\n    if (this.parser.accept(/\\(/)) {\n      ++this.parser.state;\n      const a = this.orClause();\n      if (a === null || this.parser.expect(/\\)/) === null) {\n        return null;\n      }\n      --this.parser.state;\n      return a;\n    }\n\n    return this.term();\n  }\n\n  private term(): AST | null {\n    return this.parser.oneOf([\n      this.tag.bind(this),\n      this.metatag.bind(this),\n      this.wildcard.bind(this),\n    ]);\n  }\n\n  private metatag(): AST | null {\n    let name = this.parser.expect(this.metatagRegex);\n    if (name === null) {\n      return null;\n    }\n    name = name.slice(0, -1);\n\n    const value = this.quotedString();\n    if (value === null) {\n      return null;\n    }\n\n    return new ASTMetatag(name, value);\n  }\n\n  private quotedString(): string | null {\n    if (this.parser.accept(/\"/) !== null) {\n      const a = this.parser.accept(/([^\"\\\\]|\\\\\")*/)!.replaceAll(/\\\\\"/, '\"');\n      if (this.parser.expect(/\"/) === null) {\n        return null;\n      }\n      return a;\n    }\n\n    if (this.parser.accept(/'/) !== null) {\n      const a = this.parser.accept(/([^'\\\\]|\\\\')*/)!.replaceAll(/\\\\'/, '\"');\n      if (this.parser.expect(/'/) === null) {\n        return null;\n      }\n      return a;\n    }\n\n    return this.string(/[^ ]*/);\n  }\n\n  private wildcard(): AST | null {\n    const t = this.string(/(?=[^ ]*\\*)[^ )~-][^ ]*/, true);\n    if (t === null || this.metatagRegex.exec(t)?.index === 0) {\n      return null;\n    }\n    this.space();\n    return new ASTWildcard(t);\n  }\n\n  private tag(): AST | null {\n    const t = this.string(/[^ )~-][^ ]*/, true);\n    if (\n      t === null ||\n      [\"and\", \"or\"].includes(t.toLowerCase()) ||\n      t.includes(\"*\") ||\n      this.metatagRegex.exec(t)?.index === 0\n    ) {\n      return null;\n    }\n    this.space();\n    return new ASTTag(t);\n  }\n\n  private string(\n    pattern: RegExp,\n    skipBalancedParens: boolean = false,\n  ): string | null {\n    let str = this.parser.expect(pattern);\n    if (str === null) {\n      return null;\n    }\n\n    let n = this.parser.state;\n    while (n-- > 0 && str.endsWith(\")\")) {\n      if (\n        skipBalancedParens &&\n        (QueryParser.hasBalancedParens(str) ||\n          Tag.PERMITTED_UNBALANCED_TAGS.includes(str))\n      ) {\n        break;\n      }\n\n      str = str.slice(0, -1);\n      this.parser.rewind();\n    }\n\n    return str;\n  }\n\n  private space(): string {\n    return this.parser.expect(/ */)!;\n  }\n\n  private static hasBalancedParens(\n    str: string,\n    open: string = \"(\",\n    close: string = \")\",\n  ): boolean {\n    let parens = 0;\n\n    for (const char of str) {\n      if (char === open) {\n        ++parens;\n      } else if (char === close) {\n        if (--parens < 0) {\n          return false;\n        }\n      }\n    }\n\n    return parens === 0;\n  }\n}\n","import { StringScanner } from \"./StringScanner\";\n\nexport class StringParser<StateType> {\n  private scanner: StringScanner;\n  state: StateType;\n\n  constructor(input: { toString(): string }, state: StateType) {\n    this.state = state;\n    this.scanner = new StringScanner(input);\n  }\n\n  rest(): string {\n    return this.scanner.getRemainder();\n  }\n\n  eos(): boolean {\n    return this.scanner.hasTerminated();\n  }\n\n  accept(pattern: RegExp): string | null {\n    return this.scanner.scan(pattern);\n  }\n\n  skip(pattern: RegExp): boolean {\n    return this.accept(pattern) !== null;\n  }\n\n  expect(pattern: RegExp): string | null {\n    return this.accept(pattern);\n  }\n\n  rewind(n: number = 1): void {\n    this.scanner.setPosition(this.scanner.getPosition() - n);\n  }\n\n  backtrack<T>(parser: () => T | null): T | null {\n    if (this.eos()) {\n      return null;\n    }\n\n    const savedPos = this.scanner.getPosition();\n    const savedState = window.structuredClone(this.state);\n\n    const result = parser();\n\n    if (result === null) {\n      this.scanner.setPosition(savedPos);\n      this.state = savedState;\n    }\n\n    return result;\n  }\n\n  zeroOrMore<T>(parser: () => T | null): T[] {\n    const matches: T[] = [];\n\n    for (;;) {\n      const match = this.backtrack(parser);\n      if (match === null) {\n        break;\n      }\n\n      matches.push(match);\n    }\n\n    return matches;\n  }\n\n  oneOf<T>(parsers: (() => T | null)[]): T | null {\n    for (const parser of parsers) {\n      const result = this.backtrack(parser);\n      if (result === null) {\n        continue;\n      }\n\n      return result;\n    }\n    return null;\n  }\n}\n","/*\nCopyright © 2022 Dave Thomas\n\n----\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED “AS IS,” WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\nexport class StringScanner {\n  private source: string;\n  private match!: string | null;\n  private captures!: string[];\n  private head!: number;\n  private last!: number;\n\n  /**\n   * Create a new StringScanner containing the given string.\n   *\n   * @param source The string to be scanned. If not a string,\n   * it will be converted using `toSAtring()`\n   */\n  constructor(source: { toString(): string }) {\n    this.source = source.toString();\n    this.reset();\n  }\n\n  /**\n   * The `scan`, `scanUntil`, `scanChar`, `skip`, and `skipUntil` methods look\n   * for matching strings and advance the scanner's position. The _scan_\n   * methods return the matched string; the _skip_ methods return the number\n   * of characters by which the scan position advanced.\n   * -------------------------------------------------------------------------\n   * Matches `regexp` at the current position. Returns the matched string\n   * and advances the scanner's position, or returns `null` if there is no\n   * match.\n   *\n   * @category Scanning and Skipping\n   */\n  scan(regexp: RegExp): string | null {\n    const matches = regexp.exec(this.getRemainder());\n    if (matches?.index === 0) {\n      return this.setState(matches, {\n        head: this.head + matches[0].length,\n        last: this.head,\n      });\n    } else {\n      return this.setState([]);\n    }\n  }\n\n  /**\n   * Matches `regexp` at _or after_ the current position. Returns the\n   * portion of the source string after the scanner's position up to and\n   * including the end of the match and advances the scanner's position,\n   * or returns `null` if there is no match.\n   *\n   * @category Scanning and Skipping\n   */\n  scanUntil(regexp: RegExp): string | null {\n    const matches = regexp.exec(this.getRemainder());\n    if (matches) {\n      this.setState(matches, {\n        head: this.head + matches.index + matches[0].length,\n        last: this.head,\n      });\n      return this.source.slice(this.last, this.head);\n    } else {\n      return this.setState([]);\n    }\n  }\n\n  /**\n   * Scans one character, returns it, and advances the scanner's position.\n   *\n   * @category Scanning and Skipping\n   */\n  scanChar(): string | null {\n    return this.scan(/[\\s\\S]/);\n  }\n\n  /**\n   * Skips over the given `regexp` at the current position. Returns the\n   * length of the matched string and advances the scanner's position, or\n   * returns `null` if there is no match.\n   *\n   * @category Scanning and Skipping\n   */\n  skip(regexp: RegExp): number | null {\n    if (this.scan(regexp) === null) {\n      return null;\n    }\n\n    return this.match!.length;\n  }\n\n  /**\n   * Skips over the given `regexp` at _or after_ the current position.\n   * Returns the length of the string up to and including the end of the\n   * match and advances the scanner's position, or returns `null` if there\n   * is no match.\n   *\n   * @category Scanning and Skipping\n   */\n  skipUntil(regexp: RegExp): number | null {\n    if (this.scanUntil(regexp) === null) {\n      return null;\n    }\n\n    return this.head - this.last;\n  }\n\n  /**\n   * The `check`, `checkUntil` and `peek` methods look for matching strings\n   * without advancing the scanner's position.\n   * -------------------------------------------------------------------------\n   * Checks to see if `regexp` can be matched at the current position and\n   * returns the matched string without advancing the scanner's position, or\n   * returns `null` if there is no match.\n   * @category Looking Ahead\n   *\n   */\n  check(regexp: RegExp): string | null {\n    const matches = regexp.exec(this.getRemainder());\n    if (matches === null || matches.index !== 0) {\n      return this.setState([]);\n    }\n\n    return this.setState(matches);\n  }\n\n  /**\n   * Checks to see if `regexp` can be matched at _or after_ the current\n   * position. Returns the portion of the source string after the current\n   * position up to and including the end of the match without advancing the\n   * scanner's position, or returns `null` if there is no match.\n   * @category Looking Ahead\n   *\n   */\n  checkUntil(regexp: RegExp): string | null {\n    const matches = regexp.exec(this.getRemainder());\n    if (matches === null) {\n      return this.setState([]);\n    }\n\n    this.setState(matches);\n    return this.source.slice(\n      this.head,\n      this.head + matches.index + matches[0].length,\n    );\n  }\n\n  /**\n   * Returns the next `length` characters after the current position. If\n   * called without a `length`, returns the next character. The scanner's\n   * position is not advanced.\n   *\n   * @category Looking Ahead\n   *\n   */\n  peek(length = 1): string {\n    return this.source.substring(this.head, this.head + length);\n  }\n\n  /**\n   * The `getSource`, `getRemainder`, `getPosition` and `hasTerminated`\n   * methods provide information about the scanner's source string and\n   * position.\n   * -------------------------------------------------------------------------\n   * Returns the scanner's source string.\n   *\n   * @category Accessing Scanner State\n   *\n   */\n  getSource(): string {\n    return this.source;\n  }\n\n  /**\n   * Returns the portion of the source string from the scanner's position\n   * onward.\n   *\n   * @category Accessing Scanner State\n   *\n   */\n  getRemainder(): string {\n    return this.source.slice(this.head);\n  }\n\n  /**\n   * Returns the scanner's position. In the _reset_ position, this value is\n   * zero. In the _terminated_ position, this value is the length of the\n   * source string.\n   * @category Accessing Scanner State\n   *\n   */\n  getPosition(): number {\n    return this.head;\n  }\n\n  /**\n   * Checks to see if the scanner has reached the end of the string.\n   *\n   * @category Accessing Scanner State\n   *\n   */\n  hasTerminated(): boolean {\n    return this.head === this.source.length;\n  }\n\n  /**\n   * The `getPreMatch`, `getMatch`, `getPostMatch` and `getCapture` methods\n   * provide information about the most recent match.\n   * -------------------------------------------------------------------------\n   * Returns the portion of the source string leading up to, but not\n   * including, the most recent match. (Returns `null` if there is no recent\n   * match.)\n   *\n   * @category Accessing Match Data\n   */\n  getPreMatch(): string | null {\n    if (this.match === null) {\n      return null;\n    }\n\n    return this.source.slice(0, this.head - this.match.length);\n  }\n\n  /**\n   * Returns the most recently matched portion of the source string (or\n   * `null` if there is no recent match).\n   *\n   * @category Accessing Match Data\n   */\n  getMatch(): string | null {\n    return this.match;\n  }\n\n  /**\n   * Returns the portion of the source string immediately following the most\n   * recent match. (Returns `null` if there is no recent match.)\n   *\n   * @category Accessing Match Data\n   */\n  getPostMatch(): string | null {\n    if (this.match === null) {\n      return null;\n    }\n\n    return this.source.slice(this.head);\n  }\n\n  /**\n   * Returns the `index`th capture from the most recent match (or `null` if\n   * there is no recent match).\n   *\n   * @category Accessing Match Data\n   */\n  getCapture(index: number): string | null {\n    const capture = this.captures[index];\n    if (capture === undefined) {\n      return null;\n    }\n\n    return capture;\n  }\n\n  /**\n   * The `reset`, `terminate`, `concat` and `unscan` methods let you change\n   * the state of the scanner.\n   * -------------------------------------------------------------------------\n   * Resets the scanner back to its original position and clears its match\n   * data.\n   *\n   * @category Modifying Scanner State\n   */\n  reset(): void {\n    this.setState([], { head: 0, last: 0 });\n  }\n\n  /**\n   * Advances the scanner position to the end of the string and clears its\n   * match data.\n   *\n   * @category Modifying Scanner State\n   */\n  terminate(): void {\n    this.setState([], { head: this.source.length, last: this.head });\n  }\n\n  /**\n   * Appends `string` to the scanner's source string. The scanner's position\n   * is not affected.\n   *\n   * @category Modifying Scanner State\n   */\n  concat(string: string): void {\n    this.source += string;\n  }\n\n  /**\n   * Sets the scanner's position to its previous position and clears its\n   * match data. Only one previous position is stored.\n   * Returns the previous match, or `null`.\n   *\n   * @category Modifying Scanner State\n   */\n  unscan(): string | null {\n    const match = this.match;\n\n    if (match !== undefined) {\n      this.setState([], { head: this.last, last: 0 });\n    }\n\n    return match;\n  }\n\n  /**\n   * Sets the scanner's position.\n   *\n   * @category Modifying Scanner State\n   */\n  setPosition(pos: number): void {\n    this.setState([], { head: pos, last: this.head });\n  }\n\n  //#### Private methods\n\n  /**\n   *  Sets the state of the scanner\n   *  @internal\n   */\n  private setState(\n    matches: string[],\n    { head, last }: { head?: number; last?: number } = {},\n  ): string | null {\n    if (head !== undefined) {\n      if (head < 0) {\n        head = 0;\n      }\n\n      this.head = head;\n    }\n    if (last !== undefined) {\n      this.last = last;\n    }\n\n    this.captures = matches.slice(1);\n\n    this.match = ((): string | null => {\n      const match = matches[0];\n      if (match === undefined) {\n        return null;\n      }\n\n      return match;\n    })();\n    return this.match;\n  }\n}\n","export class Tag {\n  static PERMITTED_UNBALANCED_TAGS: readonly string[] = [\n    \":)\",\n    \":(\",\n    \";)\",\n    \";(\",\n    \">:)\",\n    \">:(\",\n  ];\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { Metatag } from \"./Blacklist\";\nimport { Post } from \"./Post\";\nimport { QueryParser } from \"./QueryParser\";\n\n$(() => {\n  if ($(\"#blacklist-box\").length === 0) {\n    return;\n  }\n\n  Danbooru.Blacklist.post_match = (post, entry): boolean => {\n    if (entry.disabled) {\n      return false;\n    }\n\n    return entry.ast.match(Post.fromElement(post));\n  };\n\n  const super_parse_entry = Danbooru.Blacklist.parse_entry;\n  Danbooru.Blacklist.parse_entry = (str): BlacklistEntry => {\n    const entry = super_parse_entry(str);\n\n    entry.ast = QueryParser.parse(str, Object.values(Metatag));\n\n    return entry;\n  };\n\n  Danbooru.Blacklist.entries = [];\n  $(\"#blacklist-list\").empty();\n  $(\"#blacklist-box\").hide();\n\n  Danbooru.Blacklist.initialize_all();\n});\n"],"names":["AST","match","_post","left","right","constructor","super","this","post","node","tag","tags","includes","wildcard","regex","RegExp","replaceAll","some","exec","name","value","rating","slice","startsWith","parseInt","score","uploaderId","isPending","isFlagged","isDeleted","isBanned","hasParent","hasChildren","Metatag","Post","fromElement","dataset","split","flags","classList","contains","QueryParser","parser","metatagRegex","input","metatags","StringParser","join","parse","ast","root","eos","state","ASTNone","a","rest","zeroOrMore","orClause","bind","space","undefined","ASTAll","b","ASTAnd","andClause","accept","ASTOr","factorList","factor","expr","ASTNot","expect","term","oneOf","metatag","quotedString","ASTMetatag","string","t","index","ASTWildcard","toLowerCase","ASTTag","pattern","skipBalancedParens","str","n","endsWith","hasBalancedParens","Tag","PERMITTED_UNBALANCED_TAGS","rewind","open","close","parens","char","scanner","StringScanner","getRemainder","hasTerminated","scan","skip","setPosition","getPosition","backtrack","savedPos","savedState","window","structuredClone","result","matches","push","parsers","source","captures","head","last","toString","reset","regexp","setState","length","scanUntil","scanChar","skipUntil","check","checkUntil","peek","substring","getSource","getPreMatch","getMatch","getPostMatch","getCapture","capture","terminate","concat","unscan","pos","static","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","$","Danbooru","Blacklist","post_match","entry","disabled","super_parse_entry","parse_entry","Object","values","entries","empty","hide","initialize_all"],"sourceRoot":""}