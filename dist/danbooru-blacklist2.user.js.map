{"version":3,"file":"danbooru-blacklist2.user.js","mappings":"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","sources":["webpack://danbooru-blacklist2/./src/AST.ts","webpack://danbooru-blacklist2/./src/Blacklist.ts","webpack://danbooru-blacklist2/./src/Post.ts","webpack://danbooru-blacklist2/./src/QueryParser.ts","webpack://danbooru-blacklist2/./src/Range.ts","webpack://danbooru-blacklist2/./src/StringParser.ts","webpack://danbooru-blacklist2/./src/StringScanner.ts","webpack://danbooru-blacklist2/./src/Tag.ts","webpack://danbooru-blacklist2/webpack/bootstrap","webpack://danbooru-blacklist2/./src/index.ts"],"sourcesContent":["import { Post } from \"./Post\";\nimport { Range } from \"./Range\";\n\nexport abstract class AST {\n  abstract match(post: Post): boolean;\n\n  simplify(): AST {\n    return this;\n  }\n}\n\nexport class ASTAll extends AST {\n  override match(_post: Post): boolean {\n    return true;\n  }\n}\n\nexport class ASTNone extends AST {\n  override match(_post: Post): boolean {\n    return false;\n  }\n}\n\nexport class ASTAnd extends AST {\n  constructor(\n    readonly left: AST,\n    readonly right: AST,\n  ) {\n    super();\n  }\n\n  override match(post: Post): boolean {\n    return this.left.match(post) && this.right.match(post);\n  }\n\n  override simplify(): AST {\n    const left = this.left.simplify();\n    const right = this.right.simplify();\n\n    if (left instanceof ASTNone || right instanceof ASTNone) {\n      return new ASTNone();\n    }\n\n    if (left instanceof ASTAll) {\n      return right;\n    }\n\n    if (right instanceof ASTAll) {\n      return left;\n    }\n\n    if (left instanceof ASTAnd) {\n      return new ASTAnd(left.left, new ASTAnd(left.right, right).simplify());\n    }\n\n    return new ASTAnd(left, right);\n  }\n}\n\nexport class ASTOr extends AST {\n  constructor(\n    readonly left: AST,\n    readonly right: AST,\n  ) {\n    super();\n  }\n\n  override match(post: Post): boolean {\n    return this.left.match(post) || this.right.match(post);\n  }\n\n  override simplify(): AST {\n    const left = this.left.simplify();\n    const right = this.right.simplify();\n\n    if (left instanceof ASTAll || right instanceof ASTAll) {\n      return new ASTAll();\n    }\n\n    if (left instanceof ASTNone) {\n      return right;\n    }\n\n    if (right instanceof ASTNone) {\n      return left;\n    }\n\n    if (left instanceof ASTOr) {\n      return new ASTOr(left.left, new ASTOr(left.right, right).simplify());\n    }\n\n    return new ASTOr(left, right);\n  }\n}\n\nexport class ASTNot extends AST {\n  constructor(readonly node: AST) {\n    super();\n  }\n\n  override match(post: Post): boolean {\n    return !this.node.match(post);\n  }\n\n  override simplify(): AST {\n    const node = this.node.simplify();\n\n    if (node instanceof ASTAll) {\n      return new ASTNone();\n    }\n\n    if (node instanceof ASTNone) {\n      return new ASTAll();\n    }\n\n    if (node instanceof ASTNot) {\n      return node.node;\n    }\n\n    return new ASTNot(node);\n  }\n}\n\nexport class ASTOpt extends AST {\n  constructor(readonly node: AST) {\n    super();\n  }\n\n  override match(_post: Post): boolean {\n    throw new Error(\"not implemented\");\n  }\n}\n\nexport class ASTTag extends AST {\n  constructor(readonly tag: string) {\n    super();\n    this.tag = this.tag.toLowerCase();\n  }\n\n  override match(post: Post): boolean {\n    return post.tags\n      .map((tag) => tag.toLowerCase())\n      .includes(this.tag.toLowerCase());\n  }\n}\n\nexport class ASTWildcard extends AST {\n  private regex: RegExp;\n\n  constructor(readonly wildcard: string) {\n    super();\n\n    const pattern = this.wildcard\n      .replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\")\n      .replace(/-/g, \"\\\\x2d\")\n      .replace(/\\\\\\*/g, \"[\\\\s\\\\S]*\");\n    this.regex = RegExp(`^${pattern}$`, \"i\");\n  }\n\n  override match(post: Post): boolean {\n    return post.tags.some(\n      (tag: string): boolean => this.regex.exec(tag) !== null,\n    );\n  }\n}\n\nexport class ASTMetatag extends AST {\n  constructor(\n    readonly name: string,\n    readonly value: string,\n  ) {\n    super();\n    this.name = this.name.toLowerCase();\n  }\n\n  override match(post: Post): boolean {\n    if (this.name === \"rating\") {\n      return post.rating === this.value.slice(0, 1);\n    }\n\n    if (this.name === \"score\") {\n      const range: Range | null = Range.parse(this.value);\n      if (range === null) {\n        return false;\n      }\n\n      return range.includes(post.score);\n    }\n\n    if (this.name === \"uploaderid\") {\n      const value = parseInt(this.value);\n      return post.uploaderId === value;\n    }\n\n    if (this.name === \"is\") {\n      if (this.value === \"pending\") {\n        return post.isPending;\n      }\n\n      if (this.value === \"flagged\") {\n        return post.isFlagged;\n      }\n\n      if (this.value === \"deleted\") {\n        return post.isDeleted;\n      }\n\n      if (this.value === \"banned\") {\n        return post.isBanned;\n      }\n\n      return false;\n    }\n\n    if (this.name === \"has\") {\n      if (this.value === \"parent\") {\n        return post.hasParent;\n      }\n\n      if (this.value === \"children\") {\n        return post.hasChildren;\n      }\n\n      return false;\n    }\n\n    return false;\n  }\n}\n","export enum Metatag {\n  rating = \"rating\",\n  score = \"score\",\n  uploaderid = \"uploaderid\",\n  is = \"is\",\n  has = \"has\",\n}\n","export class Post {\n  private constructor(\n    readonly tags: string[],\n    readonly score: number,\n    readonly rating: string,\n    readonly uploaderId: number,\n    readonly isPending: boolean,\n    readonly isFlagged: boolean,\n    readonly isDeleted: boolean,\n    readonly isBanned: boolean,\n    readonly hasParent: boolean,\n    readonly hasChildren: boolean,\n  ) {}\n\n  static fromElement(post: HTMLElement): Post {\n    const tags = post.dataset[\"tags\"]!.split(\" \");\n    const score = parseInt(post.dataset[\"score\"]!)!;\n    const rating = post.dataset[\"rating\"]!;\n    const uploaderId = parseInt(post.dataset[\"uploaderId\"]!)!;\n\n    const flags = post.dataset[\"flags\"]!.split(\" \");\n    const isPending = flags.includes(\"pending\");\n    const isFlagged = flags.includes(\"flagged\");\n    const isDeleted = flags.includes(\"deleted\");\n    const isBanned = flags.includes(\"banned\");\n\n    const hasParent = post.classList.contains(\"post-status-has-parent\");\n    const hasChildren = post.classList.contains(\"post-status-has-children\");\n\n    return new Post(\n      tags,\n      score,\n      rating,\n      uploaderId,\n      isPending,\n      isFlagged,\n      isDeleted,\n      isBanned,\n      hasParent,\n      hasChildren,\n    );\n  }\n}\n","import {\n  ASTAll,\n  AST,\n  ASTTag,\n  ASTWildcard,\n  ASTMetatag,\n  ASTNot,\n  ASTAnd,\n  ASTOr,\n  ASTNone,\n  ASTOpt,\n} from \"./AST\";\nimport { StringParser } from \"./StringParser\";\nimport { Tag } from \"./Tag\";\n\nexport class QueryParser {\n  private parser: StringParser<number>;\n  private metatagRegex: RegExp;\n\n  private constructor(input: string, metatags: string[]) {\n    this.parser = new StringParser<number>(input, 0);\n    this.metatagRegex = RegExp(`(${metatags.join(\"|\")}):`, \"i\");\n  }\n\n  static parse(input: string, metatags: string[] = []): AST {\n    return new QueryParser(input, metatags).parse();\n  }\n\n  private parse(): AST {\n    let ast: AST | null = this.root();\n\n    if (!this.parser.eos()) {\n      ast = null;\n    }\n\n    if (this.parser.state !== 0) {\n      ast = null;\n    }\n\n    if (ast === null) {\n      return new ASTNone();\n    }\n\n    return ast.simplify();\n  }\n\n  private root(): AST | null {\n    const factorList = this.parser.zeroOrMore(this.orClause.bind(this));\n    this.space();\n\n    let a = new ASTAll();\n\n    for (const b of factorList) {\n      a = new ASTAnd(a, b);\n    }\n\n    return a;\n  }\n\n  private orClause(): AST | null {\n    const a = this.andClause();\n    if (a === null) {\n      return null;\n    }\n\n    this.space();\n\n    if (this.parser.accept(/or +/i) !== null) {\n      const b = this.orClause();\n      if (b === null) {\n        return null;\n      }\n      return new ASTOr(a, b);\n    }\n\n    return a;\n  }\n\n  private andClause(): AST | null {\n    const a = this.factorList();\n    if (a === null) {\n      return null;\n    }\n\n    this.space();\n\n    if (this.parser.accept(/and +/i) !== null) {\n      const b = this.andClause();\n      if (b === null) {\n        return null;\n      }\n      return new ASTAnd(a, b);\n    }\n\n    return a;\n  }\n\n  private factorList(): AST | null {\n    const factorList = this.parser.zeroOrMore(this.factor.bind(this));\n    if (factorList.length === 0) {\n      return null;\n    }\n\n    let and: AST = new ASTAll();\n    let or: AST = new ASTNone();\n\n    for (const factor of factorList) {\n      if (factor instanceof ASTOpt) {\n        or = new ASTOr(or, factor.node);\n      } else {\n        and = new ASTAnd(and, factor);\n      }\n    }\n\n    if (or instanceof ASTOr) {\n      and = new ASTAnd(and, or);\n    }\n\n    return and;\n  }\n\n  private factor(): AST | null {\n    this.space();\n\n    if (this.parser.accept(/-/) !== null) {\n      const expr = this.expr();\n      if (expr === null) {\n        return null;\n      }\n      return new ASTNot(expr);\n    }\n\n    if (this.parser.accept(/~/) !== null) {\n      const expr = this.expr();\n      if (expr === null) {\n        return null;\n      }\n      return new ASTOpt(expr);\n    }\n\n    return this.expr();\n  }\n\n  private expr(): AST | null {\n    this.space();\n\n    if (this.parser.accept(/\\(/)) {\n      ++this.parser.state;\n      const a = this.orClause();\n      if (a === null || this.parser.expect(/\\)/) === null) {\n        return null;\n      }\n      --this.parser.state;\n      return a;\n    }\n\n    return this.term();\n  }\n\n  private term(): AST | null {\n    return this.parser.oneOf([\n      this.tag.bind(this),\n      this.metatag.bind(this),\n      this.wildcard.bind(this),\n    ]);\n  }\n\n  private metatag(): AST | null {\n    let name = this.parser.expect(this.metatagRegex);\n    if (name === null) {\n      return null;\n    }\n    name = name.slice(0, -1);\n\n    const value = this.quotedString();\n    if (value === null) {\n      return null;\n    }\n\n    return new ASTMetatag(name, value);\n  }\n\n  private quotedString(): string | null {\n    if (this.parser.accept(/\"/) !== null) {\n      const a = this.parser.accept(/([^\"\\\\]|\\\\\")*/)!.replaceAll(/\\\\\"/g, '\"');\n      if (this.parser.expect(/\"/) === null) {\n        return null;\n      }\n      return a;\n    }\n\n    if (this.parser.accept(/'/) !== null) {\n      const a = this.parser.accept(/([^'\\\\]|\\\\')*/)!.replaceAll(/\\\\'/g, \"'\");\n      if (this.parser.expect(/'/) === null) {\n        return null;\n      }\n      return a;\n    }\n\n    return this.string(/[^ ]*/);\n  }\n\n  private wildcard(): AST | null {\n    const t = this.string(/(?=[^ ]*\\*)[^ )~-][^ ]*/, true);\n    if (t === null || this.metatagRegex.exec(t)?.index === 0) {\n      return null;\n    }\n    this.space();\n    return new ASTWildcard(t);\n  }\n\n  private tag(): AST | null {\n    const t = this.string(/[^ )~-][^ ]*/, true);\n    if (\n      t === null ||\n      [\"and\", \"or\"].includes(t.toLowerCase()) ||\n      t.includes(\"*\") ||\n      this.metatagRegex.exec(t)?.index === 0\n    ) {\n      return null;\n    }\n    this.space();\n    return new ASTTag(t);\n  }\n\n  private string(\n    pattern: RegExp,\n    skipBalancedParens: boolean = false,\n  ): string | null {\n    let str = this.parser.expect(pattern);\n    if (str === null) {\n      return null;\n    }\n\n    let n = this.parser.state;\n    while (n-- > 0 && str.endsWith(\")\")) {\n      if (\n        skipBalancedParens &&\n        (QueryParser.hasBalancedParens(str) ||\n          Tag.PERMITTED_UNBALANCED_TAGS.includes(str))\n      ) {\n        break;\n      }\n\n      str = str.slice(0, -1);\n      this.parser.rewind();\n    }\n\n    return str;\n  }\n\n  private space(): string {\n    return this.parser.expect(/ */)!;\n  }\n\n  private static hasBalancedParens(\n    str: string,\n    open: string = \"(\",\n    close: string = \")\",\n  ): boolean {\n    let parens = 0;\n\n    for (const char of str) {\n      if (char === open) {\n        ++parens;\n      } else if (char === close) {\n        if (--parens < 0) {\n          return false;\n        }\n      }\n    }\n\n    return parens === 0;\n  }\n}\n","type ValueType = number;\n\nexport abstract class Range {\n  abstract includes(value: ValueType): boolean;\n\n  static parse(expr: string): Range | null {\n    const subclasses = [\n      RangeUnion,\n      RangeExclusive,\n      RangeInclusive,\n      RangeLtEq,\n      RangeLt,\n      RangeGtEq,\n      RangeGt,\n      RangeAny,\n      RangeNone,\n      RangeEq,\n    ];\n\n    for (const subclass of subclasses) {\n      const range: Range | null = subclass.parse(expr);\n\n      if (range !== null) {\n        return range;\n      }\n    }\n\n    return null;\n  }\n\n  protected static parseValue(value: string): ValueType {\n    return parseInt(value);\n  }\n}\n\nclass RangeUnion extends Range {\n  protected constructor(readonly ranges: readonly Range[]) {\n    super();\n  }\n\n  static override parse(expr: string): Range | null {\n    if (/[, ]/.exec(expr) === null) {\n      return null;\n    }\n\n    const ranges: Range[] = [];\n    for (const innerExpr of expr.split(/[, ]+/)) {\n      const innerRange: Range | null = Range.parse(innerExpr);\n      if (innerRange === null) {\n        return null;\n      }\n      ranges.push(innerRange);\n    }\n\n    return new this(ranges);\n  }\n\n  override includes(value: ValueType): boolean {\n    return this.ranges.some((range) => range.includes(value));\n  }\n}\n\nclass RangeExclusive extends Range {\n  protected static readonly REGEX = /^(.+?)\\.\\.\\.(.+)/;\n\n  protected constructor(\n    readonly start: ValueType,\n    readonly end: ValueType,\n  ) {\n    super();\n  }\n\n  static override parse(expr: string): Range | null {\n    const match = this.REGEX.exec(expr);\n    if (match === null) {\n      return null;\n    }\n    const start = this.parseValue(match[1]!);\n    const end = this.parseValue(match[2]!);\n    return new this(start, end);\n  }\n\n  override includes(value: ValueType): boolean {\n    return this.start <= value && value < this.end;\n  }\n}\n\nclass RangeInclusive extends RangeExclusive {\n  protected static override readonly REGEX = /^(.+?)\\.\\.(.+)/;\n\n  override includes(value: ValueType): boolean {\n    return this.start <= value && value <= this.end;\n  }\n}\n\nclass RangeGt extends Range {\n  protected static readonly REGEX = /^>(.+)/;\n\n  protected constructor(readonly value: ValueType) {\n    super();\n  }\n\n  static override parse(expr: string): Range | null {\n    const match = this.REGEX.exec(expr);\n    if (match === null) {\n      return null;\n    }\n\n    const value = this.parseValue(match.filter(Boolean)[1]!);\n    return new this(value);\n  }\n\n  override includes(value: ValueType): boolean {\n    return value > this.value;\n  }\n}\n\nclass RangeLt extends RangeGt {\n  protected static override readonly REGEX = /^<(.+)/;\n\n  override includes(value: ValueType): boolean {\n    return value < this.value;\n  }\n}\n\nclass RangeGtEq extends RangeGt {\n  protected static override readonly REGEX = /^(?:>=(.+)|(.+)\\.\\.$)/;\n\n  override includes(value: ValueType): boolean {\n    return value >= this.value;\n  }\n}\n\nclass RangeLtEq extends RangeGt {\n  protected static override readonly REGEX = /^(?:<=(.+)|\\.\\.(.+))/;\n\n  override includes(value: ValueType): boolean {\n    return value <= this.value;\n  }\n}\n\nclass RangeNone extends Range {\n  protected static readonly VALUE: string = \"none\";\n\n  static override parse(expr: string): Range | null {\n    if (expr !== this.VALUE) {\n      return null;\n    }\n    return new this();\n  }\n\n  override includes(value: ValueType): boolean {\n    return Number.isNaN(value);\n  }\n}\n\nclass RangeAny extends RangeNone {\n  protected static override readonly VALUE: string = \"any\";\n\n  override includes(value: ValueType): boolean {\n    return !super.includes(value);\n  }\n}\n\nclass RangeEq extends Range {\n  protected constructor(readonly value: ValueType) {\n    super();\n  }\n\n  static override parse(expr: string): Range {\n    const value = this.parseValue(expr);\n    return new this(value);\n  }\n\n  override includes(value: ValueType): boolean {\n    return value === this.value;\n  }\n}\n","import { StringScanner } from \"./StringScanner\";\n\nexport class StringParser<StateType> {\n  private scanner: StringScanner;\n  state: StateType;\n\n  constructor(input: { toString(): string }, state: StateType) {\n    this.state = state;\n    this.scanner = new StringScanner(input);\n  }\n\n  rest(): string {\n    return this.scanner.getRemainder();\n  }\n\n  eos(): boolean {\n    return this.scanner.hasTerminated();\n  }\n\n  accept(pattern: RegExp): string | null {\n    return this.scanner.scan(pattern);\n  }\n\n  skip(pattern: RegExp): boolean {\n    return this.accept(pattern) !== null;\n  }\n\n  expect(pattern: RegExp): string | null {\n    return this.accept(pattern);\n  }\n\n  rewind(n: number = 1): void {\n    this.scanner.setPosition(this.scanner.getPosition() - n);\n  }\n\n  backtrack<T>(parser: () => T | null): T | null {\n    if (this.eos()) {\n      return null;\n    }\n\n    const savedPos = this.scanner.getPosition();\n    const savedState = structuredClone(this.state);\n\n    const result = parser();\n\n    if (result === null) {\n      this.scanner.setPosition(savedPos);\n      this.state = savedState;\n    }\n\n    return result;\n  }\n\n  zeroOrMore<T>(parser: () => T | null): T[] {\n    const matches: T[] = [];\n\n    for (;;) {\n      const match = this.backtrack(parser);\n      if (match === null) {\n        break;\n      }\n\n      matches.push(match);\n    }\n\n    return matches;\n  }\n\n  oneOf<T>(parsers: (() => T | null)[]): T | null {\n    for (const parser of parsers) {\n      const result = this.backtrack(parser);\n      if (result === null) {\n        continue;\n      }\n\n      return result;\n    }\n    return null;\n  }\n}\n","/*\nCopyright © 2022 Dave Thomas\n\n----\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED “AS IS,” WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\nexport class StringScanner {\n  private source: string;\n  private match!: string | null;\n  private captures!: string[];\n  private head!: number;\n  private last!: number;\n\n  /**\n   * Create a new StringScanner containing the given string.\n   *\n   * @param source The string to be scanned. If not a string,\n   * it will be converted using `toSAtring()`\n   */\n  constructor(source: { toString(): string }) {\n    this.source = source.toString();\n    this.reset();\n  }\n\n  /**\n   * The `scan`, `scanUntil`, `scanChar`, `skip`, and `skipUntil` methods look\n   * for matching strings and advance the scanner's position. The _scan_\n   * methods return the matched string; the _skip_ methods return the number\n   * of characters by which the scan position advanced.\n   * -------------------------------------------------------------------------\n   * Matches `regexp` at the current position. Returns the matched string\n   * and advances the scanner's position, or returns `null` if there is no\n   * match.\n   *\n   * @category Scanning and Skipping\n   */\n  scan(regexp: RegExp): string | null {\n    const matches = regexp.exec(this.getRemainder());\n    if (matches?.index === 0) {\n      return this.setState(matches, {\n        head: this.head + matches[0].length,\n        last: this.head,\n      });\n    } else {\n      return this.setState([]);\n    }\n  }\n\n  /**\n   * Matches `regexp` at _or after_ the current position. Returns the\n   * portion of the source string after the scanner's position up to and\n   * including the end of the match and advances the scanner's position,\n   * or returns `null` if there is no match.\n   *\n   * @category Scanning and Skipping\n   */\n  scanUntil(regexp: RegExp): string | null {\n    const matches = regexp.exec(this.getRemainder());\n    if (matches) {\n      this.setState(matches, {\n        head: this.head + matches.index + matches[0].length,\n        last: this.head,\n      });\n      return this.source.slice(this.last, this.head);\n    } else {\n      return this.setState([]);\n    }\n  }\n\n  /**\n   * Scans one character, returns it, and advances the scanner's position.\n   *\n   * @category Scanning and Skipping\n   */\n  scanChar(): string | null {\n    return this.scan(/[\\s\\S]/);\n  }\n\n  /**\n   * Skips over the given `regexp` at the current position. Returns the\n   * length of the matched string and advances the scanner's position, or\n   * returns `null` if there is no match.\n   *\n   * @category Scanning and Skipping\n   */\n  skip(regexp: RegExp): number | null {\n    if (this.scan(regexp) === null) {\n      return null;\n    }\n\n    return this.match!.length;\n  }\n\n  /**\n   * Skips over the given `regexp` at _or after_ the current position.\n   * Returns the length of the string up to and including the end of the\n   * match and advances the scanner's position, or returns `null` if there\n   * is no match.\n   *\n   * @category Scanning and Skipping\n   */\n  skipUntil(regexp: RegExp): number | null {\n    if (this.scanUntil(regexp) === null) {\n      return null;\n    }\n\n    return this.head - this.last;\n  }\n\n  /**\n   * The `check`, `checkUntil` and `peek` methods look for matching strings\n   * without advancing the scanner's position.\n   * -------------------------------------------------------------------------\n   * Checks to see if `regexp` can be matched at the current position and\n   * returns the matched string without advancing the scanner's position, or\n   * returns `null` if there is no match.\n   * @category Looking Ahead\n   *\n   */\n  check(regexp: RegExp): string | null {\n    const matches = regexp.exec(this.getRemainder());\n    if (matches === null || matches.index !== 0) {\n      return this.setState([]);\n    }\n\n    return this.setState(matches);\n  }\n\n  /**\n   * Checks to see if `regexp` can be matched at _or after_ the current\n   * position. Returns the portion of the source string after the current\n   * position up to and including the end of the match without advancing the\n   * scanner's position, or returns `null` if there is no match.\n   * @category Looking Ahead\n   *\n   */\n  checkUntil(regexp: RegExp): string | null {\n    const matches = regexp.exec(this.getRemainder());\n    if (matches === null) {\n      return this.setState([]);\n    }\n\n    this.setState(matches);\n    return this.source.slice(\n      this.head,\n      this.head + matches.index + matches[0].length,\n    );\n  }\n\n  /**\n   * Returns the next `length` characters after the current position. If\n   * called without a `length`, returns the next character. The scanner's\n   * position is not advanced.\n   *\n   * @category Looking Ahead\n   *\n   */\n  peek(length = 1): string {\n    return this.source.substring(this.head, this.head + length);\n  }\n\n  /**\n   * The `getSource`, `getRemainder`, `getPosition` and `hasTerminated`\n   * methods provide information about the scanner's source string and\n   * position.\n   * -------------------------------------------------------------------------\n   * Returns the scanner's source string.\n   *\n   * @category Accessing Scanner State\n   *\n   */\n  getSource(): string {\n    return this.source;\n  }\n\n  /**\n   * Returns the portion of the source string from the scanner's position\n   * onward.\n   *\n   * @category Accessing Scanner State\n   *\n   */\n  getRemainder(): string {\n    return this.source.slice(this.head);\n  }\n\n  /**\n   * Returns the scanner's position. In the _reset_ position, this value is\n   * zero. In the _terminated_ position, this value is the length of the\n   * source string.\n   * @category Accessing Scanner State\n   *\n   */\n  getPosition(): number {\n    return this.head;\n  }\n\n  /**\n   * Checks to see if the scanner has reached the end of the string.\n   *\n   * @category Accessing Scanner State\n   *\n   */\n  hasTerminated(): boolean {\n    return this.head === this.source.length;\n  }\n\n  /**\n   * The `getPreMatch`, `getMatch`, `getPostMatch` and `getCapture` methods\n   * provide information about the most recent match.\n   * -------------------------------------------------------------------------\n   * Returns the portion of the source string leading up to, but not\n   * including, the most recent match. (Returns `null` if there is no recent\n   * match.)\n   *\n   * @category Accessing Match Data\n   */\n  getPreMatch(): string | null {\n    if (this.match === null) {\n      return null;\n    }\n\n    return this.source.slice(0, this.head - this.match.length);\n  }\n\n  /**\n   * Returns the most recently matched portion of the source string (or\n   * `null` if there is no recent match).\n   *\n   * @category Accessing Match Data\n   */\n  getMatch(): string | null {\n    return this.match;\n  }\n\n  /**\n   * Returns the portion of the source string immediately following the most\n   * recent match. (Returns `null` if there is no recent match.)\n   *\n   * @category Accessing Match Data\n   */\n  getPostMatch(): string | null {\n    if (this.match === null) {\n      return null;\n    }\n\n    return this.source.slice(this.head);\n  }\n\n  /**\n   * Returns the `index`th capture from the most recent match (or `null` if\n   * there is no recent match).\n   *\n   * @category Accessing Match Data\n   */\n  getCapture(index: number): string | null {\n    const capture = this.captures[index];\n    if (capture === undefined) {\n      return null;\n    }\n\n    return capture;\n  }\n\n  /**\n   * The `reset`, `terminate`, `concat` and `unscan` methods let you change\n   * the state of the scanner.\n   * -------------------------------------------------------------------------\n   * Resets the scanner back to its original position and clears its match\n   * data.\n   *\n   * @category Modifying Scanner State\n   */\n  reset(): void {\n    this.setState([], { head: 0, last: 0 });\n  }\n\n  /**\n   * Advances the scanner position to the end of the string and clears its\n   * match data.\n   *\n   * @category Modifying Scanner State\n   */\n  terminate(): void {\n    this.setState([], { head: this.source.length, last: this.head });\n  }\n\n  /**\n   * Appends `string` to the scanner's source string. The scanner's position\n   * is not affected.\n   *\n   * @category Modifying Scanner State\n   */\n  concat(string: string): void {\n    this.source += string;\n  }\n\n  /**\n   * Sets the scanner's position to its previous position and clears its\n   * match data. Only one previous position is stored.\n   * Returns the previous match, or `null`.\n   *\n   * @category Modifying Scanner State\n   */\n  unscan(): string | null {\n    const match = this.match;\n\n    if (match !== undefined) {\n      this.setState([], { head: this.last, last: 0 });\n    }\n\n    return match;\n  }\n\n  /**\n   * Sets the scanner's position.\n   *\n   * @category Modifying Scanner State\n   */\n  setPosition(pos: number): void {\n    this.setState([], { head: pos, last: this.head });\n  }\n\n  //#### Private methods\n\n  /**\n   *  Sets the state of the scanner\n   *  @internal\n   */\n  private setState(\n    matches: string[],\n    { head, last }: { head?: number; last?: number } = {},\n  ): string | null {\n    if (head !== undefined) {\n      if (head < 0) {\n        head = 0;\n      }\n\n      this.head = head;\n    }\n    if (last !== undefined) {\n      this.last = last;\n    }\n\n    this.captures = matches.slice(1);\n\n    this.match = ((): string | null => {\n      const match = matches[0];\n      if (match === undefined) {\n        return null;\n      }\n\n      return match;\n    })();\n    return this.match;\n  }\n}\n","export class Tag {\n  static PERMITTED_UNBALANCED_TAGS: readonly string[] = [\n    \":)\",\n    \":(\",\n    \";)\",\n    \";(\",\n    \">:)\",\n    \">:(\",\n  ];\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { Metatag } from \"./Blacklist\";\nimport { Post } from \"./Post\";\nimport { QueryParser } from \"./QueryParser\";\n\n$(() => {\n  if ($(\"#blacklist-box\").length === 0) {\n    return;\n  }\n\n  Danbooru.Blacklist.post_match = (post, entry): boolean => {\n    if (entry.disabled) {\n      return false;\n    }\n\n    return entry.ast.match(Post.fromElement(post));\n  };\n\n  const super_parse_entry = Danbooru.Blacklist.parse_entry;\n  Danbooru.Blacklist.parse_entry = (str): BlacklistEntry => {\n    const entry = super_parse_entry(str);\n\n    entry.ast = QueryParser.parse(str, Object.values(Metatag));\n\n    return entry;\n  };\n\n  Danbooru.Blacklist.entries = [];\n  $(\"#blacklist-list\").empty();\n  $(\"#blacklist-box\").hide();\n\n  Danbooru.Blacklist.initialize_all();\n});\n"],"names":["AST","simplify","this","ASTAll","match","_post","ASTNone","ASTAnd","left","right","constructor","super","post","ASTOr","ASTNot","node","Error","tag","toLowerCase","tags","map","includes","wildcard","regex","pattern","replace","RegExp","some","exec","name","value","rating","slice","range","Range","parse","score","parseInt","uploaderId","isPending","isFlagged","isDeleted","isBanned","hasParent","hasChildren","Metatag","Post","fromElement","dataset","split","flags","classList","contains","QueryParser","parser","metatagRegex","input","metatags","StringParser","join","ast","root","eos","state","factorList","zeroOrMore","orClause","bind","space","a","b","andClause","accept","factor","length","and","or","ASTOpt","expr","expect","term","oneOf","metatag","quotedString","ASTMetatag","replaceAll","string","t","index","ASTWildcard","ASTTag","skipBalancedParens","str","n","endsWith","hasBalancedParens","Tag","PERMITTED_UNBALANCED_TAGS","rewind","open","close","parens","char","subclasses","RangeUnion","RangeExclusive","RangeInclusive","RangeLtEq","RangeLt","RangeGtEq","RangeGt","RangeAny","RangeNone","RangeEq","subclass","parseValue","ranges","innerExpr","innerRange","push","start","end","static","REGEX","filter","Boolean","VALUE","Number","isNaN","scanner","StringScanner","rest","getRemainder","hasTerminated","scan","skip","setPosition","getPosition","backtrack","savedPos","savedState","structuredClone","result","matches","parsers","source","captures","head","last","toString","reset","regexp","setState","scanUntil","scanChar","skipUntil","check","checkUntil","peek","substring","getSource","getPreMatch","getMatch","getPostMatch","getCapture","capture","undefined","terminate","concat","unscan","pos","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","$","Danbooru","Blacklist","post_match","entry","disabled","super_parse_entry","parse_entry","Object","values","entries","empty","hide","initialize_all"],"sourceRoot":""}